(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[433],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return s},kt:function(){return h}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},s=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=d(t),h=a,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||r;return t?i.createElement(m,o(o({ref:n},s),{},{components:t})):i.createElement(m,o({ref:n},s))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=u;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var d=2;d<r;d++)o[d]=t[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7804:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return p},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return s},default:function(){return u}});var i=t(2122),a=t(9756),r=(t(7294),t(3905)),o=["components"],p={},l="Making a Native Android Application that uses PyTorch prebuilt libraries",d={unversionedId:"building/android_native_app_with_custom_op",id:"building/android_native_app_with_custom_op",isDocsHomePage:!1,title:"Making a Native Android Application that uses PyTorch prebuilt libraries",description:"Author: Ivan Kobzarev",source:"@site/docs/building/android_native_app_with_custom_op.md",sourceDirName:"building",slug:"/building/android_native_app_with_custom_op",permalink:"/mobile-ds/docs/building/android_native_app_with_custom_op",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/building/android_native_app_with_custom_op.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Quantization",permalink:"/mobile-ds/docs/modelprep/quantization"},next:{title:"Building PyTorch Android from Source",permalink:"/mobile-ds/docs/building/androidbuild"}},s=[{value:"Setup",id:"setup",children:[]},{value:"Preparing TorchScript Model With Custom C++ Operator",id:"preparing-torchscript-model-with-custom-c-operator",children:[]},{value:"Making Android Application",id:"making-android-application",children:[]},{value:"Android Application Build Setup",id:"android-application-build-setup",children:[{value:"Gradle Build Setup",id:"gradle-build-setup",children:[]},{value:"Native Build CMake Setup",id:"native-build-cmake-setup",children:[]},{value:"Adding the model file to the application",id:"adding-the-model-file-to-the-application",children:[]},{value:"Android Application Manifest",id:"android-application-manifest",children:[]},{value:"Sources",id:"sources",children:[]},{value:"Java Code",id:"java-code",children:[]},{value:"Native code",id:"native-code",children:[]},{value:"Building the app",id:"building-the-app",children:[]}]}],c={toc:s};function u(e){var n=e.components,t=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"making-a-native-android-application-that-uses-pytorch-prebuilt-libraries"},"Making a Native Android Application that uses PyTorch prebuilt libraries"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Author"),": ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/IvanKobzarev"},"Ivan Kobzarev")),(0,r.kt)("p",null,"In this recipe, you will learn:"),(0,r.kt)("blockquote",null,(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"How to make an Android Application that uses LibTorch API from\nnative code (C++)."),(0,r.kt)("li",{parentName:"ul"},"How to use within this application TorchScript models with custom\noperators."))),(0,r.kt)("p",null,"The full setup of this app you can find in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pytorch/android-demo-app/tree/master/NativeApp"},"PyTorch Android Demo\nApplication\nRepository"),"."),(0,r.kt)("h2",{id:"setup"},"Setup"),(0,r.kt)("p",null,"You will need a Python 3 environment with the following packages (and\ntheir dependencies) installed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"PyTorch 1.6")),(0,r.kt)("p",null,"For Android development, you will need to install:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Android NDK")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wget https://dl.google.com/android/repository/android-ndk-r19c-linux-x86_64.zip\nunzip android-ndk-r19c-linux-x86_64.zip\nexport ANDROID_NDK=$(pwd)/android-ndk-r19c\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Android SDK")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip\nunzip sdk-tools-linux-3859397.zip -d android_sdk\nexport ANDROID_HOME=$(pwd)/android_sdk\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Gradle 4.10.3")),(0,r.kt)("p",null,"Gradle is the most widely used build system for android applications,\nand we will need it to build our application. Download it and add to the\npath to use ",(0,r.kt)("inlineCode",{parentName:"p"},"gradle")," in the command line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'wget https://services.gradle.org/distributions/gradle-4.10.3-bin.zip\nunzip gradle-4.10.3-bin.zip\nexport GRADLE_HOME=$(pwd)/gradle-4.10.3\nexport PATH="${GRADLE_HOME}/bin/:${PATH}"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"JDK")),(0,r.kt)("p",null,"Gradle requires JDK, you need to install it and set environment variable\n",(0,r.kt)("inlineCode",{parentName:"p"},"JAVA_HOME")," to point to it. For example you can install OpenJDK,\nfollowing ",(0,r.kt)("a",{parentName:"p",href:"https://openjdk.java.net/install/"},"instructions"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"OpenCV SDK for Android")),(0,r.kt)("p",null,"Our custom operator will be implemented using the OpenCV library. To use\nit for Android, we need to download OpenCV SDK for Android with prebuilt\nlibraries. Download from ",(0,r.kt)("a",{parentName:"p",href:"https://opencv.org/releases/"},"OpenCV releases\npage"),". Unzip it and set the environment\nvariable ",(0,r.kt)("inlineCode",{parentName:"p"},"OPENCV_ANDROID_SDK")," to it."),(0,r.kt)("h2",{id:"preparing-torchscript-model-with-custom-c-operator"},"Preparing TorchScript Model With Custom C++ Operator"),(0,r.kt)("p",null,"TorchScript allows using custom C++ operators, to read about it with\ndetails you can read ",(0,r.kt)("a",{parentName:"p",href:"https://pytorch.org/tutorials/advanced/torch_script_custom_ops.html"},"the dedicated\ntutorial"),"."),(0,r.kt)("p",null,"As a result, you can script the model that uses custom op, that uses\nOpenCV ",(0,r.kt)("inlineCode",{parentName:"p"},"cv::warpPerspective")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'import torch\nimport torch.utils.cpp_extension\n\nprint(torch.version.__version__)\nop_source = """\n#include <opencv2/opencv.hpp>\n#include <torch/script.h>\n\ntorch::Tensor warp_perspective(torch::Tensor image, torch::Tensor warp) {\n  cv::Mat image_mat(/*rows=*/image.size(0),\n                    /*cols=*/image.size(1),\n                    /*type=*/CV_32FC1,\n                    /*data=*/image.data_ptr<float>());\n  cv::Mat warp_mat(/*rows=*/warp.size(0),\n                   /*cols=*/warp.size(1),\n                   /*type=*/CV_32FC1,\n                   /*data=*/warp.data_ptr<float>());\n\n  cv::Mat output_mat;\n  cv::warpPerspective(image_mat, output_mat, warp_mat, /*dsize=*/{64, 64});\n\n  torch::Tensor output =\n    torch::from_blob(output_mat.ptr<float>(), /*sizes=*/{64, 64});\n  return output.clone();\n}\n\nstatic auto registry =\n  torch::RegisterOperators("my_ops::warp_perspective", &warp_perspective);\n"""\n\ntorch.utils.cpp_extension.load_inline(\n    name="warp_perspective",\n    cpp_sources=op_source,\n    extra_ldflags=["-lopencv_core", "-lopencv_imgproc"],\n    is_python_module=False,\n    verbose=True,\n)\n\nprint(torch.ops.my_ops.warp_perspective)\n\n\n@torch.jit.script\ndef compute(x, y):\n    if bool(x[0][0] == 42):\n        z = 5\n    else:\n        z = 10\n    x = torch.ops.my_ops.warp_perspective(x, torch.eye(3))\n    return x.matmul(y) + z\n\n\ncompute.save("compute.pt")\n')),(0,r.kt)("p",null,"This snippet generates ",(0,r.kt)("inlineCode",{parentName:"p"},"compute.pt")," file which is TorchScript model that\nuses custom op ",(0,r.kt)("inlineCode",{parentName:"p"},"my_ops.warp_perspective"),"."),(0,r.kt)("p",null,"You need to have installed OpenCV for development to run it. For Linux\nsystems that can be done using the next commands: CentOS:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"yum install opencv-devel\n")),(0,r.kt)("p",null,"Ubuntu:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"apt-get install libopencv-dev\n")),(0,r.kt)("h2",{id:"making-android-application"},"Making Android Application"),(0,r.kt)("p",null,"After we succeeded in having ",(0,r.kt)("inlineCode",{parentName:"p"},"compute.pt"),", we want to use this\nTorchScript model within Android application. Using general TorchScript\nmodels (without custom operators) on Android, using Java API, you can\nfind ",(0,r.kt)("a",{parentName:"p",href:"https://pytorch.org/mobile/android/"},"here"),". We can not use this\napproach for our case, as our model uses a custom\noperator(",(0,r.kt)("inlineCode",{parentName:"p"},"my_ops.warp_perspective"),"), default TorchScript execution will\nfail to find it."),(0,r.kt)("p",null,"Registration of ops is not exposed to PyTorch Java API, thus we need to\nbuild Android Application with native part (C++) and using LibTorch C++\nAPI to implement and register the same custom operator for Android. As\nour operator uses the OpenCV library - we will use prebuilt OpenCV\nAndroid libraries and use the same functions from OpenCV."),(0,r.kt)("p",null,"Let's start creating Android application in ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp")," folder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mkdir NativeApp\ncd NativeApp\n")),(0,r.kt)("h2",{id:"android-application-build-setup"},"Android Application Build Setup"),(0,r.kt)("p",null,"Android Application build consists of the main gradle part and native\nbuild CMake part. All the listings here are the full file listing, that\nif to recreate the whole structure, you will be able to build and\ninstall the result Android Application without any code additions."),(0,r.kt)("h3",{id:"gradle-build-setup"},"Gradle Build Setup"),(0,r.kt)("p",null,"We will need to add gradle setup files: build.gradle, gradle.properties,\nsettings.gradle. More about Android Gradle build configurations you can\nfind ",(0,r.kt)("a",{parentName:"p",href:"https://developer.android.com/studio/build"},"here"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/settings.gradle")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"include ':app'\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/gradle.properties")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"android.useAndroidX=true\nandroid.enableJetifier=true\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/build.gradle")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"buildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.5.0'\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n")),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/build.gradle")," we specify Android gradle plugin version"),(0,r.kt)("span",{class:"title-ref"},"3.5.0"),". This version is not recent. Still, we use it as PyTorch android gradle builds use this version.",(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/settings.gradle")," shows that out project contains only one\nmodule - ",(0,r.kt)("inlineCode",{parentName:"p"},"app"),", which will be our Android Application."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mkdir app\ncd app\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/build.gradle")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'apply plugin: \'com.android.application\'\n\nrepositories {\n  jcenter()\n  maven {\n    url "https://oss.sonatype.org/content/repositories/snapshots"\n  }\n}\n\nandroid {\n  configurations {\n    extractForNativeBuild\n  }\n  compileSdkVersion 28\n  buildToolsVersion "29.0.2"\n  defaultConfig {\n    applicationId "org.pytorch.nativeapp"\n    minSdkVersion 21\n    targetSdkVersion 28\n    versionCode 1\n    versionName "1.0"\n    externalNativeBuild {\n      cmake {\n        arguments "-DANDROID_STL=c++_shared"\n      }\n    }\n  }\n  buildTypes {\n    release {\n      minifyEnabled false\n    }\n  }\n  externalNativeBuild {\n    cmake {\n      path "CMakeLists.txt"\n    }\n  }\n  sourceSets {\n    main {\n      jniLibs.srcDirs = [\'src/main/jniLibs\']\n    }\n  }\n}\n\ndependencies {\n  implementation \'com.android.support:appcompat-v7:28.0.0\'\n\n  implementation \'org.pytorch:pytorch_android:1.6.0-SNAPSHOT\'\n  extractForNativeBuild \'org.pytorch:pytorch_android:1.6.0-SNAPSHOT\'\n}\n\ntask extractAARForNativeBuild {\n  doLast {\n    configurations.extractForNativeBuild.files.each {\n      def file = it.absoluteFile\n      copy {\n        from zipTree(file)\n        into "$buildDir/$file.name"\n        include "headers/**"\n        include "jni/**"\n      }\n    }\n  }\n}\n\ntasks.whenTaskAdded { task ->\n  if (task.name.contains(\'externalNativeBuild\')) {\n    task.dependsOn(extractAARForNativeBuild)\n  }\n}\n')),(0,r.kt)("p",null,"This gradle build script registers dependencies on pytorch","_","android\nsnapshots, that are published on nightly channels."),(0,r.kt)("p",null,"As they are published to nexus sonatype repository - we need to register\nthat repository:\n",(0,r.kt)("inlineCode",{parentName:"p"},"https://oss.sonatype.org/content/repositories/snapshots"),"."),(0,r.kt)("p",null,"In our application we need to use LibTorch C++ API in our application\nnative build part. For this, we need access to prebuilt binaries and\nheaders. They are prepacked in PyTorch Android builds, which is\npublished in Maven repositories."),(0,r.kt)("p",null,"To use PyTorch Android prebuilt libraries from gradle dependencies\n(which is aar files) - we should add registration for configuration\n",(0,r.kt)("inlineCode",{parentName:"p"},"extractForNativeBuild"),", add this configuration in dependencies and put\nits definition in the end."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"extractForNativeBuild")," task will call ",(0,r.kt)("inlineCode",{parentName:"p"},"extractAARForNativeBuild")," task\nthat unpacks pytorch","_","android aar to gradle build directory."),(0,r.kt)("p",null,"Pytorch","_","android aar contains LibTorch headers in ",(0,r.kt)("inlineCode",{parentName:"p"},"headers")," folder and\nprebuilt libraries for different Android abis in ",(0,r.kt)("inlineCode",{parentName:"p"},"jni")," folder:\n",(0,r.kt)("inlineCode",{parentName:"p"},"$ANDROID_ABI/libpytorch_jni.so"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"$ANDROID_ABI/libfbjni.so"),". We will\nuse them for our native build."),(0,r.kt)("p",null,"The native build is registered in this ",(0,r.kt)("inlineCode",{parentName:"p"},"build.gradle")," with lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'android {\n  ...\n  externalNativeBuild {\n    cmake {\n      path "CMakeLists.txt"\n    }\n}\n...\ndefaultConfig {\n  externalNativeBuild {\n    cmake {\n      arguments "-DANDROID_STL=c++_shared"\n    }\n  }\n}\n')),(0,r.kt)("p",null,"We will use ",(0,r.kt)("inlineCode",{parentName:"p"},"CMake")," configuration for a native build. Here we also\nspecify that we will dynamically link with STL, as we have several\nlibraries. More about this, you can find\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.android.com/ndk/guides/cpp-support"},"here"),"."),(0,r.kt)("h3",{id:"native-build-cmake-setup"},"Native Build CMake Setup"),(0,r.kt)("p",null,"The native build will be configured in ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/CMakeLists.txt"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'cmake_minimum_required(VERSION 3.4.1)\nset(TARGET pytorch_nativeapp)\nproject(${TARGET} CXX)\nset(CMAKE_CXX_STANDARD 14)\n\nset(build_DIR ${CMAKE_SOURCE_DIR}/build)\n\nset(pytorch_testapp_cpp_DIR ${CMAKE_CURRENT_LIST_DIR}/src/main/cpp)\nfile(GLOB pytorch_testapp_SOURCES\n  ${pytorch_testapp_cpp_DIR}/pytorch_nativeapp.cpp\n)\n\nadd_library(${TARGET} SHARED\n    ${pytorch_testapp_SOURCES}\n)\n\nfile(GLOB PYTORCH_INCLUDE_DIRS "${build_DIR}/pytorch_android*.aar/headers")\nfile(GLOB PYTORCH_LINK_DIRS "${build_DIR}/pytorch_android*.aar/jni/${ANDROID_ABI}")\n\ntarget_compile_options(${TARGET} PRIVATE\n  -fexceptions\n)\n\nset(BUILD_SUBDIR ${ANDROID_ABI})\n\nfind_library(PYTORCH_LIBRARY pytorch_jni\n  PATHS ${PYTORCH_LINK_DIRS}\n  NO_CMAKE_FIND_ROOT_PATH)\nfind_library(FBJNI_LIBRARY fbjni\n  PATHS ${PYTORCH_LINK_DIRS}\n  NO_CMAKE_FIND_ROOT_PATH)\n\n# OpenCV\nif(NOT DEFINED ENV{OPENCV_ANDROID_SDK})\n  message(FATAL_ERROR "Environment var OPENCV_ANDROID_SDK is not set")\nendif()\n\nset(OPENCV_INCLUDE_DIR "$ENV{OPENCV_ANDROID_SDK}/sdk/native/jni/include")\n\ntarget_include_directories(${TARGET} PRIVATE\n "${OPENCV_INCLUDE_DIR}"\n  ${PYTORCH_INCLUDE_DIRS})\n\nset(OPENCV_LIB_DIR "$ENV{OPENCV_ANDROID_SDK}/sdk/native/libs/${ANDROID_ABI}")\n\nfind_library(OPENCV_LIBRARY opencv_java4\n  PATHS ${OPENCV_LIB_DIR}\n  NO_CMAKE_FIND_ROOT_PATH)\n\ntarget_link_libraries(${TARGET}\n  ${PYTORCH_LIBRARY}\n  ${FBJNI_LIBRARY}\n  ${OPENCV_LIBRARY}\n  log)\n')),(0,r.kt)("p",null,"Here we register only one source file ",(0,r.kt)("inlineCode",{parentName:"p"},"pytorch_nativeapp.cpp"),"."),(0,r.kt)("p",null,"On the previous step in ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/build.gradle"),", the task\n",(0,r.kt)("inlineCode",{parentName:"p"},"extractAARForNativeBuild")," extracts headers and native libraries to\nbuild directory. We set ",(0,r.kt)("inlineCode",{parentName:"p"},"PYTORCH_INCLUDE_DIRS")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"PYTORCH_LINK_DIRS"),"\nto them."),(0,r.kt)("p",null,"After that, we find libraries ",(0,r.kt)("inlineCode",{parentName:"p"},"libpytorch_jni.so")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"libfbjni.so")," and\nadd them to the linking of our target."),(0,r.kt)("p",null,"As we plan to use OpenCV functions to implement our custom operator\n",(0,r.kt)("inlineCode",{parentName:"p"},"my_ops::warp_perspective")," - we need to link to ",(0,r.kt)("inlineCode",{parentName:"p"},"libopencv_java4.so"),". It\nis packaged in OpenCV SDK for Android, that was downloaded on the Setup\nstep. In this configuration, we find it by environment variable\n",(0,r.kt)("inlineCode",{parentName:"p"},"OPENCV_ANDROID_SDK"),"."),(0,r.kt)("p",null,"We also link with ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," library to be able to log our results to Android\nLogCat."),(0,r.kt)("p",null,"As we link to OpenCV Android SDK's ",(0,r.kt)("inlineCode",{parentName:"p"},"libopencv_java4.so"),", we should copy\nit to ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/jniLibs/${ANDROID_ABI}")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cp -R $OPENCV_ANDROID_SDK/sdk/native/libs/* NativeApp/app/src/main/jniLibs/\n")),(0,r.kt)("h3",{id:"adding-the-model-file-to-the-application"},"Adding the model file to the application"),(0,r.kt)("p",null,"To package the TorschScript model ",(0,r.kt)("inlineCode",{parentName:"p"},"compute.pt")," within our application we\nshould copy it to assets folder:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mkdir -p NativeApp/app/src/main/assets\ncp compute.pt NativeApp/app/src/main/assets\n")),(0,r.kt)("h3",{id:"android-application-manifest"},"Android Application Manifest"),(0,r.kt)("p",null,"Every Android application has a manifest. Here we specify the\napplication name, package, main activity."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/AndroidManifest.xml"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'<?xml version="1.0" encoding="utf-8"?>\n<manifest xmlns:android="http://schemas.android.com/apk/res/android"\n    package="org.pytorch.nativeapp">\n\n    <application\n        android:allowBackup="true"\n        android:label="PyTorchNativeApp"\n        android:supportsRtl="true"\n        android:theme="@style/Theme.AppCompat.Light.DarkActionBar">\n\n        <activity android:name=".MainActivity">\n            <intent-filter>\n                <action android:name="android.intent.action.MAIN" />\n                <category android:name="android.intent.category.LAUNCHER" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n')),(0,r.kt)("h3",{id:"sources"},"Sources"),(0,r.kt)("h3",{id:"java-code"},"Java Code"),(0,r.kt)("p",null,"Now we are ready to implement our MainActivity in"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/java/org/pytorch/nativeapp/MainActivity.java"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'package org.pytorch.nativeapp;\n\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.util.Log;\nimport androidx.appcompat.app.AppCompatActivity;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class MainActivity extends AppCompatActivity {\n\n  private static final String TAG = "PyTorchNativeApp";\n\n  public static String assetFilePath(Context context, String assetName) {\n    File file = new File(context.getFilesDir(), assetName);\n    if (file.exists() && file.length() > 0) {\n      return file.getAbsolutePath();\n    }\n\n    try (InputStream is = context.getAssets().open(assetName)) {\n      try (OutputStream os = new FileOutputStream(file)) {\n        byte[] buffer = new byte[4 * 1024];\n        int read;\n        while ((read = is.read(buffer)) != -1) {\n          os.write(buffer, 0, read);\n        }\n        os.flush();\n      }\n      return file.getAbsolutePath();\n    } catch (IOException e) {\n      Log.e(TAG, "Error process asset " + assetName + " to file path");\n    }\n    return null;\n  }\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    final String modelFileAbsoluteFilePath =\n        new File(assetFilePath(this, "compute.pt")).getAbsolutePath();\n    NativeClient.loadAndForwardModel(modelFileAbsoluteFilePath);\n  }\n}\n')),(0,r.kt)("p",null,"In the previous step, when we copied our ",(0,r.kt)("inlineCode",{parentName:"p"},"compute.pt")," to\n",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/assets")," that file became an Android application\nasset, which will be packed in application. Android system provides only\nstream access to it. To use this module from LibTorch, we need to\nmaterialize it as a file on the disk. ",(0,r.kt)("inlineCode",{parentName:"p"},"assetFilePath")," function copies\ndata from the asset input stream, writes it on the disk, and returns\nabsolute file path for it."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"OnCreate")," method of Activity is called just after Activity creation. In\nthis method, we call ",(0,r.kt)("inlineCode",{parentName:"p"},"assertFilePath")," and call ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeClient")," class that\nwill dispatch it to native code through JNI call."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeClient")," is a helper class with an internal private class\n",(0,r.kt)("inlineCode",{parentName:"p"},"NativePeer"),", which is responsible for working with the native part of\nour application. It has a static block that will load\n",(0,r.kt)("inlineCode",{parentName:"p"},"libpytorch_nativeapp.so"),", that is build with ",(0,r.kt)("inlineCode",{parentName:"p"},"CMakeLists.txt")," that we\nadded on the previous step. The static block will be executed with the\nfirst reference of ",(0,r.kt)("inlineCode",{parentName:"p"},"NativePeer")," class. It happens in\n",(0,r.kt)("inlineCode",{parentName:"p"},"NativeClient#loadAndForwardModel"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/java/org/pytorch/nativeapp/NativeClient.java"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'package org.pytorch.nativeapp;\n\npublic final class NativeClient {\n\n  public static void loadAndForwardModel(final String modelPath) {\n    NativePeer.loadAndForwardModel(modelPath);\n  }\n\n  private static class NativePeer {\n    static {\n      System.loadLibrary("pytorch_nativeapp");\n    }\n\n    private static native void loadAndForwardModel(final String modelPath);\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativePeer#loadAndForwardModel")," is declared as ",(0,r.kt)("inlineCode",{parentName:"p"},"native"),", it does not\nhave definition in Java. Call to this method will be re-dispatched\nthrough JNI to C++ method in our ",(0,r.kt)("inlineCode",{parentName:"p"},"libpytorch_nativeapp.so"),", in\n",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/cpp/pytorch_nativeapp.cpp"),"."),(0,r.kt)("h3",{id:"native-code"},"Native code"),(0,r.kt)("p",null,"Now we are ready to write a native part of our application."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/cpp/pytorch_nativeapp.cpp"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'#include <android/log.h>\n#include <cassert>\n#include <cmath>\n#include <pthread.h>\n#include <unistd.h>\n#include <vector>\n#define ALOGI(...)                                                             \\\n  __android_log_print(ANDROID_LOG_INFO, "PyTorchNativeApp", __VA_ARGS__)\n#define ALOGE(...)                                                             \\\n  __android_log_print(ANDROID_LOG_ERROR, "PyTorchNativeApp", __VA_ARGS__)\n\n#include "jni.h"\n\n#include <opencv2/opencv.hpp>\n#include <torch/script.h>\n\nnamespace pytorch_nativeapp {\nnamespace {\ntorch::Tensor warp_perspective(torch::Tensor image, torch::Tensor warp) {\n  cv::Mat image_mat(/*rows=*/image.size(0),\n                    /*cols=*/image.size(1),\n                    /*type=*/CV_32FC1,\n                    /*data=*/image.data_ptr<float>());\n  cv::Mat warp_mat(/*rows=*/warp.size(0),\n                   /*cols=*/warp.size(1),\n                   /*type=*/CV_32FC1,\n                   /*data=*/warp.data_ptr<float>());\n\n  cv::Mat output_mat;\n  cv::warpPerspective(image_mat, output_mat, warp_mat, /*dsize=*/{8, 8});\n\n  torch::Tensor output =\n      torch::from_blob(output_mat.ptr<float>(), /*sizes=*/{8, 8});\n  return output.clone();\n}\n\nstatic auto registry =\n    torch::RegisterOperators("my_ops::warp_perspective", &warp_perspective);\n\ntemplate <typename T> void log(const char *m, T t) {\n  std::ostringstream os;\n  os << t << std::endl;\n  ALOGI("%s %s", m, os.str().c_str());\n}\n\nstruct JITCallGuard {\n  torch::autograd::AutoGradMode no_autograd_guard{false};\n  torch::AutoNonVariableTypeMode non_var_guard{true};\n  torch::jit::GraphOptimizerEnabledGuard no_optimizer_guard{false};\n};\n} // namespace\n\nstatic void loadAndForwardModel(JNIEnv *env, jclass, jstring jModelPath) {\n  const char *modelPath = env->GetStringUTFChars(jModelPath, 0);\n  assert(modelPath);\n  JITCallGuard guard;\n  torch::jit::Module module = torch::jit::load(modelPath);\n  module.eval();\n  torch::Tensor x = torch::randn({4, 8});\n  torch::Tensor y = torch::randn({8, 5});\n  log("x:", x);\n  log("y:", y);\n  c10::IValue t_out = module.forward({x, y});\n  log("result:", t_out);\n  env->ReleaseStringUTFChars(jModelPath, modelPath);\n}\n} // namespace pytorch_nativeapp\n\nJNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *) {\n  JNIEnv *env;\n  if (vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) != JNI_OK) {\n    return JNI_ERR;\n  }\n\n  jclass c = env->FindClass("org/pytorch/nativeapp/NativeClient$NativePeer");\n  if (c == nullptr) {\n    return JNI_ERR;\n  }\n\n  static const JNINativeMethod methods[] = {\n      {"loadAndForwardModel", "(Ljava/lang/String;)V",\n       (void *)pytorch_nativeapp::loadAndForwardModel},\n  };\n  int rc = env->RegisterNatives(c, methods,\n                                sizeof(methods) / sizeof(JNINativeMethod));\n\n  if (rc != JNI_OK) {\n    return rc;\n  }\n\n  return JNI_VERSION_1_6;\n}\n')),(0,r.kt)("p",null,"This listing is quite long, and a few things intermixed here, we will\nfollow control flow to understand how this code works. The first place\nwhere the control flow arrives is ",(0,r.kt)("inlineCode",{parentName:"p"},"JNI_OnLoad"),". This function is called\nafter loading the library. It is responsible for registering native\nmethod, which is called when ",(0,r.kt)("inlineCode",{parentName:"p"},"NativePeer#loadAndForwardModel")," called,\nhere it is ",(0,r.kt)("inlineCode",{parentName:"p"},"pytorch_nativeapp::loadAndForwardModel")," function."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pytorch_nativeapp::loadAndForwardModel")," takes as an argument model\npath. First, we extract its ",(0,r.kt)("inlineCode",{parentName:"p"},"const char*")," value and loading the module\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"torch::jit::load"),"."),(0,r.kt)("p",null,"To load TorchScript model for mobile, we need to set these guards,\nbecause mobile build doesn't support features like autograd for smaller\nbuild size, placed in ",(0,r.kt)("inlineCode",{parentName:"p"},"struct JITCallGuard")," in this example. It may\nchange in the future. You can track the latest changes keeping an eye on\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pytorch/pytorch/blob/master/android/pytorch_android/src/main/cpp/pytorch_jni_jit.cpp"},"source in PyTorch\nGitHub"),"."),(0,r.kt)("p",null,"Implementation of method ",(0,r.kt)("inlineCode",{parentName:"p"},"warp_perspective")," and registration of it is\nentirely the same as in ",(0,r.kt)("a",{parentName:"p",href:"https://pytorch.org/tutorials/advanced/torch_script_custom_ops.html"},"tutorial for desktop\nbuild"),"."),(0,r.kt)("h3",{id:"building-the-app"},"Building the app"),(0,r.kt)("p",null,"To specify to gradle where is Android SDK and Android NDK, we need to\nfill ",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/local.properties"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'cd NativeApp\necho "sdk.dir=$ANDROID_HOME" >> NativeApp/local.properties\necho "ndk.dir=$ANDROID_NDK" >> NativeApp/local.properties\n')),(0,r.kt)("p",null,"To build the result ",(0,r.kt)("inlineCode",{parentName:"p"},"apk")," file we run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cd NativeApp\ngradle app:assembleDebug\n")),(0,r.kt)("p",null,"To install the app on the connected device:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cd NativeApp\ngradle app::installDebug\n")),(0,r.kt)("p",null,"After that, you can run the app on the device by clicking on\nPyTorchNativeApp icon. Or you can do it from the command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"adb shell am start -n org.pytorch.nativeapp/.MainActivity\n")),(0,r.kt)("p",null,"If you check the android logcat:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"adb logcat -v brief | grep PyTorchNativeApp\n")),(0,r.kt)("p",null,"You should see logs with tag 'PyTorchNativeApp' that prints x, y, and\nthe result of the model forward, which we print with ",(0,r.kt)("inlineCode",{parentName:"p"},"log")," function in\n",(0,r.kt)("inlineCode",{parentName:"p"},"NativeApp/app/src/main/cpp/pytorch_nativeapp.cpp"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"I/PyTorchNativeApp(26968): x: -0.9484 -1.1757 -0.5832  0.9144  0.8867  1.0933 -0.4004 -0.3389\nI/PyTorchNativeApp(26968): -1.0343  1.5200 -0.7625 -1.5724 -1.2073  0.4613  0.2730 -0.6789\nI/PyTorchNativeApp(26968): -0.2247 -1.2790  1.0067 -0.9266  0.6034 -0.1941  0.7021 -1.5368\nI/PyTorchNativeApp(26968): -0.3803 -0.0188  0.2021 -0.7412 -0.2257  0.5044  0.6592  0.0826\nI/PyTorchNativeApp(26968): [ CPUFloatType{4,8} ]\nI/PyTorchNativeApp(26968): y: -1.0084  1.8733  0.5435  0.1087 -1.1066\nI/PyTorchNativeApp(26968): -1.9926  1.1047  0.5311 -0.4944  1.9178\nI/PyTorchNativeApp(26968): -1.5451  0.8867  1.0473 -1.7571  0.3909\nI/PyTorchNativeApp(26968):  0.4039  0.5085 -0.2776  0.4080  0.9203\nI/PyTorchNativeApp(26968):  0.3655  1.4395 -1.4467 -0.9837  0.3335\nI/PyTorchNativeApp(26968): -0.0445  0.8039 -0.2512 -1.3122  0.6543\nI/PyTorchNativeApp(26968): -1.5819  0.0525  1.5680 -0.6442 -1.3090\nI/PyTorchNativeApp(26968): -1.6197 -0.0773 -0.5967 -0.1105 -0.3122\nI/PyTorchNativeApp(26968): [ CPUFloatType{8,5} ]\nI/PyTorchNativeApp(26968): result:  16.0274   9.0330   6.0124   9.8644  11.0493\nI/PyTorchNativeApp(26968):   8.7633   6.9657  12.3469  10.3159  12.0683\nI/PyTorchNativeApp(26968):  12.4529   9.4559  11.7038   7.8396   6.9716\nI/PyTorchNativeApp(26968):   8.5279   9.1780  11.3849   8.4368   9.1480\nI/PyTorchNativeApp(26968):  10.0000  10.0000  10.0000  10.0000  10.0000\nI/PyTorchNativeApp(26968):  10.0000  10.0000  10.0000  10.0000  10.0000\nI/PyTorchNativeApp(26968):  10.0000  10.0000  10.0000  10.0000  10.0000\nI/PyTorchNativeApp(26968):  10.0000  10.0000  10.0000  10.0000  10.0000\nI/PyTorchNativeApp(26968): [ CPUFloatType{8,5} ]\n")),(0,r.kt)("p",null,"The full setup of this app you can find in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pytorch/android-demo-app/tree/master/NativeApp"},"PyTorch Android Demo\nApplication\nRepository"),"."))}u.isMDXComponent=!0}}]);